{"version":3,"sources":["components/SearchBar.tsx","components/Emoji.tsx","components/EmojiList.tsx","components/Loader.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["SearchBar","search","setSearch","className","value","onChange","e","target","autoComplete","type","name","placeholder","Emoji","title","symbol","EmojiList","handleScroll","emojisToShow","onScroll","map","emoji","Loader","App","useState","loading","setLoading","emojis","setEmojis","setEmojisToShow","filteredEmojis","setFilteredEmojis","useEffect","axios","get","then","response","data","spliced","splice","searchInput","trim","toLowerCase","isMultipleWords","indexOf","filtered","filter","match","keywords","split","find","keyword","found","searchWord","includes","length","undefined","scrollHeight","scrollTop","clientHeight","moreEmojis","concat","showMoreEmojis","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3ea75f84.chunk.js","sourcesContent":["import { IoSearch } from \"react-icons/io5\";\r\nimport { SearchBarProps } from \"../models/SearchBarProps\";\r\n\r\nconst SearchBar: React.FC<SearchBarProps> = ({ search, setSearch }) => {\r\n  return (\r\n    <div data-testid=\"searchBar\" className=\"searchBar\">\r\n      <div className=\"searchBox\">\r\n        <IoSearch />\r\n        <input\r\n          value={search}\r\n          onChange={(e) => setSearch(e.target.value)}\r\n          className=\"searchField\"\r\n          autoComplete=\"off\"\r\n          type=\"text\"\r\n          name=\"search\"\r\n          placeholder=\"Search for an emoji using a keyword\"\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SearchBar;\r\n","import { EmojiProps } from \"../models/EmojiProps\";\r\n\r\nconst Emoji: React.FC<EmojiProps> = ({ title, symbol }) => {\r\n  return (\r\n    <div\r\n      data-testid={title}\r\n      title={title}\r\n      className=\"col-4 col-md-3 col-lg-2 emoji\"\r\n    >\r\n      {symbol}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Emoji;\r\n","import { EmojiListProps } from \"../models/EmojiListProps\";\r\nimport Emoji from \"./Emoji\";\r\n\r\nconst EmojiList: React.FC<EmojiListProps> = ({\r\n  handleScroll,\r\n  emojisToShow,\r\n}) => {\r\n  return (\r\n    <section\r\n      data-testid={\"emojiList\"}\r\n      className=\"emojisSection\"\r\n      onScroll={handleScroll}\r\n    >\r\n      <div className=\"row\">\r\n        {emojisToShow &&\r\n          emojisToShow.map((emoji) => {\r\n            return (\r\n              <Emoji\r\n                key={emoji.title}\r\n                title={emoji.title}\r\n                symbol={emoji.symbol}\r\n              />\r\n            );\r\n          })}\r\n      </div>\r\n    </section>\r\n  );\r\n};\r\n\r\nexport default EmojiList;\r\n","import { Spinner } from \"reactstrap\";\r\n\r\nconst Loader: React.FC = () => {\r\n  return (\r\n    <div className=\"loader\">\r\n      <Spinner>Loading...</Spinner>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Loader;\r\n","import React, { useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport { EmojiProps } from \"./models/EmojiProps\";\nimport axios from \"axios\";\nimport SearchBar from \"./components/SearchBar\";\nimport EmojiList from \"./components/EmojiList\";\nimport Loader from \"./components/Loader\";\n\nfunction App() {\n  // initializing states using react hooks and using appropriate types\n  const [loading, setLoading] = useState(false);\n  const [emojis, setEmojis] = useState<EmojiProps[]>();\n  const [emojisToShow, setEmojisToShow] = useState<EmojiProps[]>();\n  const [filteredEmojis, setFilteredEmojis] = useState<EmojiProps[]>();\n  const [search, setSearch] = useState(\"\");\n\n  // this effect will be called on each initial render and won't repeat\n  // this effect is used to fetch the list of emojis and assign it to emojis state\n  useEffect(() => {\n    setLoading(true);\n    axios\n      .get(\n        `https://raw.githubusercontent.com/SalesChamp/emoji-list/main/emoji-list.json`\n      )\n      .then((response) => {\n        setLoading(false);\n        setEmojis(response.data);\n      });\n  }, []);\n\n  // this effect runs whenever a change occurs in the emojis or filteredEmojis state changed\n  // this function helps with the infinite scroll functionality\n  useEffect(() => {\n    // first we need to check if we are dealing with filtered (searched) or non filtered list of emojis\n    // then we will show the first (from 0 to 50) emojis from either list\n    if (filteredEmojis) {\n      let spliced = [...filteredEmojis].splice(0, 50);\n      setEmojisToShow(spliced);\n    } else if (emojis) {\n      let spliced = [...emojis].splice(0, 50);\n      setEmojisToShow(spliced);\n    }\n  }, [emojis, filteredEmojis]);\n\n  // this effect runs whenever the value of the search text has changed\n  // meaning it will run whenever a user changes the search value\n  useEffect(() => {\n    // if indeed there was text in the search field, then filter emojis based on whether the search text is contained in one of the keyword values of each emoji\n    if (search) {\n      // first we need to detect if search input consists of one word or two or more words\n      let searchInput = search.trim().toLowerCase();\n      let isMultipleWords = false\n      // we do that by checking the existance of the space character after trimming\n      if(searchInput.indexOf(' ') !== -1) {\n        isMultipleWords = true\n      }\n      var filtered = emojis?.filter((emoji) => {\n        let keywords = emoji.keywords ? emoji.keywords.split(\" \") : [];\n        let match = keywords.find((keyword) => {\n          // if search input is two or more words, then we need to check both words for any matches in the keywords\n          if(isMultipleWords) {\n            let found = false;\n            for(let searchWord of searchInput.split(' ')) {\n              if(keyword.includes(searchWord)) {\n                found = true;\n                break\n              }\n            }\n            return found\n          } else {\n            return keyword.includes(searchInput)\n          }\n        });\n        return match && match.length > 0;\n      });\n      setFilteredEmojis(filtered);\n    } else {\n      // if no text in the search value (user erased their search)\n      // set filteredEmojis state as undefined to let the app know to show the original list of emojis\n      setFilteredEmojis(undefined);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [search]);\n\n  // this function is called whenever a user has scrolled to the end of the emoji list\n  // this is part of the infinite scroll functionality, adding the next 50 emojis to the emojisToShow state\n  const showMoreEmojis = () => {\n    // first we need to check whether we're dealing with original list or filtered list\n    if (filteredEmojis && emojisToShow) {\n      if (emojisToShow.length < filteredEmojis.length) {\n        let moreEmojis = emojisToShow.concat(\n          [...filteredEmojis].splice(emojisToShow.length, 50)\n        );\n        setEmojisToShow(moreEmojis);\n      }\n    } else if (emojis && emojisToShow) {\n      if (emojisToShow.length < emojis.length) {\n        let moreEmojis = emojisToShow.concat(\n          [...emojis].splice(emojisToShow.length, 50)\n        );\n        setEmojisToShow(moreEmojis);\n      }\n    }\n  };\n\n  // this function runs whenever a scroll event fires\n  // it will check if the user has almost reached the end of the list, then it will ask for more emojis to show\n  const handleScroll = (e: any) => {\n    const bottom =\n      e.target.scrollHeight - e.target.scrollTop <= e.target.clientHeight + 100;\n    if (bottom) {\n      showMoreEmojis();\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"headerSection\">\n        <h2>Emoji Search</h2>\n      </header>\n      {loading ? (\n        <Loader />\n      ) : (\n        <section className=\"mainSection\">\n          <SearchBar search={search} setSearch={setSearch} />\n          <EmojiList emojisToShow={emojisToShow} handleScroll={handleScroll} />\n        </section>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}